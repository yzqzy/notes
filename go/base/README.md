# Tony Bai - Go语言第一课

## 推荐入坑理由

* 对初学者足够友好，能够快速上手
  * 语法简单，可以快速学习语法，编写简单、实用应用
  * 设计者在发布 Go 1.0 版本和兼容性规范后，主要精力还是打磨 Go 实现，改进周边工具链
* 生产力与性能的最佳组合
  * 创建最初目的，就是构建流行的、高性能的服务端编程语言
  * 性能也有明显优势，与不带 GC 的静态编程语言（C/C++）之间也没有数量级的差距
  * 对于动态语言用户友好，并且和动态语言相比，可以在保持生产力的同时，大幅度提高性能
  * 在云原生基础设施、中间件与云服务领域大放异彩
  * 可以应用在 DevOps/SRE、区块链、命令行交互程序（CLI）、Web 服务，数据处理方面
* 快乐且具有前景
  * 相对于 C/C++、Java，Go 在开发体验上有很多提升，包括简单的语法、得心应手的工具链、丰富和健壮的标准库，生产力与性能的完美结合，免除内存管理的心智负担，对并发设计的原生支持等等
  * 可以使用 Go 体现自身价值，有非常广泛的应用场景

## GO 历史与现状

### Go 语言是怎样诞生的

Go 语言的创始人有三位，分别是图灵奖获得者、C 语言联合发明人、Unix 之父肯·汤普森（Ken Thompson ），Plan 9 操作系统领导者、UTF - 8 编码的最初设计者罗伯·派克（Rob Pike），以及 Java 的 HotSpot 虚拟机和 Chrome 浏览器的 JavaScript V8 引擎的设计者之一罗伯特·格瑞史莫（Robert Griesemer）。

他们三个人在 2007 年 9 月 20 日下午的一次普通讨论，成了计算机编程语言领域的一次著名历史事件，开启了一个新编程语言的历史。

在谷歌山景城总部的办公室里，罗伯 · 派克启动了一个 C++ 工程的构建，根据以往的经验，这次构建大约需要一个小时。利用这段时间，罗伯·派克和罗伯特·格瑞史莫、肯·汤普森坐在一起，交换了关于设计一门新编程语言的想法。

之所以产生这种想法，是因为当时谷歌内部主要适用 C++ 语言构建各种系统，但 C++ 的巨大复杂性，编译构建速度慢以及在编写服务端程序时对并发支持的不足，让三位大佬觉得非常不便，于是他们就想着设计一门新的语言。在他们的初步构想中，这门新语言应该是能够给程序员带来快乐、匹配未来硬件发展趋势并适合用来开发谷歌大规模网络服务程序的。

在一天的简短讨论后，第二天三位大佬具体讨论了这门新语言的设计。会后罗伯特·格瑞史发出电邮，对这门新编程语言的功能特性做了初步归纳总结。主要思路是，在 C 语言的基础上，修正一些明显的缺陷，删除一些被诟病较多的特性，增加一些缺失的功能。例如，使用 import 替代 include、去掉宏、增加垃圾回收、支持接口等。这封电邮成为这门新语言的第一版特性设计稿，三位大佬在这门语言的一些基础语法特性上达成初步一致。

9 月 25 日，罗伯·派克在一封回复电邮中把这门新编程语言命名为 “go”。在罗伯 · 派克的心目中，“go” 这个单词短小、容易输入并且在组合其他字母后便可以用来命名 Go 相关的工具，比如编译器（goc）、汇编器（goa）、链接器（gol）等。

> go 早期版本曾如此命名 go 工具链，但后续版本撤销了这种命名方式，仅保留 go 这一统一的工具链名称。

另外，很多 Go 语言初学者经常称这门语言为 Golang，其实这是不对的：“Golang” 仅应用于命名 Go 语言官网网站，没有使用 go.com 纯粹是因为这个域名被占用了而已。

### “三人行” 到 ”众人拾柴“

经过早期讨论，Go 语言的三位作者在语言设计达成初步一致后，便开启了 Go 语言迭代设计和实现的过程。

2008 年初，Unix 之父肯·汤普森实现了第一版 Go 编译器，用于验证之前的设计。这个编译器先将 Go 代码转换为 C 代码，再由 C 编译器编译成二进制文件。

2008 年年中，Go 的第一版设计就基本结束了。这是，同样在谷歌工作的伊恩·泰勒（Ian Lance Taylor）为 Go 语言实现了一个 gcc 的前端，这也是 Go 语言的第二个编译器。伊恩·泰勒的成本不仅仅是一种鼓励，也证明了 Go 这一新语言的可行性。随后，伊恩·泰勒以团队第四位成员的身份正式加入 Go 语言开发团队，后面也成了 Go 语言，以及其工具设计和实现的核心人物之一。

> 一个编译器的完整编译过程包括：词法分析、语法分析、类型检查、中间代码生成、代码优化、目标代码生成、目标代码优化等几个阶段。从词法分析到中间代码生成，这就是编译器前端所要负责的事情。代码优化和目标代码生成，则是编译器后端的职责。
>
> 上面所说的实现 gcc 的前端，就是实现一个程序，这个程序可以读取 go 源码并通过词法分析、语法分析、类型检查，最终生成中间代码，而这个中间代码可以被 gcc 后端所识别并生成最终目标代码。

罗斯·考克斯（Russ Cox）是 Go 核心开发团队的第五位成员，也是在 2008 年加入。随后，罗斯·考克斯利用函数是 “一等公民”，并且它也可以拥有自己的方法这一特性设计出了 http 包的 HandlerFunc 类型。这样，我们通过显式转型就可以让一个普通函数称为满足 http.Handler 接口的类型。

> 在 Go 中，如果一个变量的类型为 int，如果我们要将其与另一个 int 64 类型的变量进行加法运算，我们不能直接将它们相加，我们必须将它们显示的转换为同一类型后才能想家，这里的转换过程就简称为显式转型。

不仅如此，罗斯·考克斯还在当时设计的基础上提出一些更泛化的想法，比如 io.Reader 和 io.Writer 接口，这就奠定了 Go 语言的 I/O 结构模型。后来，罗斯·考克斯成为 Go 核心技术团队的负责人，推动 Go 语言的持续演化。

至此，Go 语言最初的核心团队形成，Go 语言迈上稳定演化的道路。

2009 年 10 月 30 日，罗伯·派克在 Google Techtalk 上做了一次有关 Go 语言的演讲，“The Go Programming Language”，这是 Go 语言第一次公之于众。十天后，2009 年 11 月 10 日，谷歌官方宣布 Go 语言项目开源，之后这一天也被 Go 官方确定为 Go 语言的诞生日。

在 Go 语言项目开源后，Go 语言也迎来了自己的 “吉祥物”，是一只由罗伯·派克夫人芮妮·弗伦奇（Renee French）设计的地鼠，从此地鼠（gopher）也就成为了世界各地 Go 程序员的象征，Go 程序员也被昵称为 Gopher。

<img src="./images/go.png" />

Go 语言项目的开源吸引了全世界开发者的目光，再加上 Go 三位作者在业界的影响力以及谷歌这座大树的加持，更多有才华的程序员加入到 Go 核心开发团队中，更多贡献者开始为 Go 语言项目添砖加瓦。于是，Go 在宣布开源的当年，就成为了著名编程排行榜 TIOBE 的年度编程语言。

2012 年 3 月 28 日，Go 1.0 版本正式发布，同时 Go 官方发布了 “Go 1 兼容性” 承诺：只要符合 Go 1 语言规范的源代码，Go 编译器将保证向后兼容（backwards compatible），也就是说我们使用新版编译器也可以正确编译用老版本语法编写的代码。

从正式开源到现在，Go 语言发布了多个大版本更新，逐渐成熟。下面梳理了迄今为止 Go 语言的重大版本更新，希望可以帮助你快速了解 Go 语言的演化历史。

<img src="./images/go_history.png" />

经过十余年的打磨与优化，如何的 Go 语言已经逐渐成为云计算时代基础设施的编程语言。你能想到的现代云计算基础设施软件的大部分流行和可靠的作品，都是用 Go 编写的，比如：Docker、Kubernetes、Prometheus、Ethereum（以太坊）、lstio、CockroachDB、InfluxDB、Terraform、Etcd、Consul 等等，可以看 Go 语言的影响力已经十分强大。

### 总结

一门编程语言的历史和现状，可以给你带来学习的 “安全感”，相信它可以提升你的个人价值，也会让你获得丰富的回报。你也会更加清楚地认识到：自己为什么要学习它？它未来的发展趋势又是怎样的？当这门语言的现状能给予你极大 “安全感” 的时候，我们才会 “死心塌地” 地学习和钻研这门技术，不会有太多的后顾之忧。

从 Go 本身的发展来看，和多数编程语言一样，Go 语言在诞生后，度过了一个较长 “技术萌芽期”。然后，实现了自举，发布对 GC 延迟进行大幅优化的 Go 1.5 版本，成为 Go 语言演化过程中的第一个 “引爆点”，推动 Go 语言进入 “技术膨胀期”。

也正是在这段时间内，Go 语言推出了以 Docker、Kubernetes 为典型代表的 “杀手级应用”，充分展示了实力，在世界范围收获了百万粉丝，迸发出极高的潜力和持续的活力。

## Go 语言的设计哲学

很多编程语言的初学者在学习初期，可能都会遇到这样的问题：最初兴致勃勃地开始学习一门编程语言，学着学着就发现很多 “别扭” 的地方，比如想要的语言特性缺失、语法风格偏避与主流语言差异大、语言的不同版本之间无法兼容、语言的语法特性过多导致学习曲线陡峭、语言的工具链支持较差，等等。

以上的这些问题，本质上都与语言设计者的设计哲学有关。所谓编程语言的设计哲学，就是指决定这门语言演化进程的高级原则和依据。

设计哲学之余编程语言，就好比一个人的价值观之余这个人的行为。如果不认同这个人的价值观，那你就很难与之持续交往下去。同理，如果你不认同一门编程语言的设计哲学，那么大概率你会在后续的语言学习中，就会遇到上面提到的问题，而且可能会让你失去继续学习的精神动力。

因此，在正式学习 Go 语法和编码之前，我们还需要先来了解一下 Go 语言的设计哲学。

Go 语言的设计哲学可以总结为五点：简单、显式、组合、并发和面向工程。

### 简单

Go 语言的设计者们在语言设计之初，就拒绝走语言特性融合的道路，选择 “做减法” 并致力于打造一门简单的编程语言。

这也就意味着 Go 不会像 C++、Java 那样将其他编程语言的新特性兼蓄并收，所以你在 Go 语言中看不到传统的面向对象的类、构造函数与继承，看不到结构化的异常处理，也看不到本属于函数编程范式的语法元素。

不过，Go 语也没它看起来那么简单，自身实现起来也并不容易，但这些复杂性都被 Go 语言的设计者们 “隐藏” 了，所以 Go 语法层面上呈现这样的状态：

* 仅有 25 个关键字，主流编程语言很少；
* 内置垃圾收集，降低开发人员内存管理的心智负担；
* 首字母大小写决定可见性，无需通过额外关键字修饰；
* 变量初始为类型零值，避免以随机值作为初值的问题；
* 内置数组边界检查，极大减少越界访问带来的安全隐患；
* 内置并发支持，简化并发程序设计；
* 内置接口类型，为组合的设计哲学奠定基础；
* 原生提供完善的工具链，开箱即用；
* ... ...

我们可以看到 Go 设计者选择的 “简单”，其实是站在巨人肩膀上，去除或优化了以往语言中，已经被开发者证明为体验不好或难以驾驭的语法元素和语言机制，并提出自己的一些创新性的设计。比如，首字母大小写决定可见性、变量初始为类型零值、内置以 go 关键字实现的并发支持等。

简单意味着可以使用更少的代码实现相同的功能，简单意味着代码具有更好的可读性，可读性好的代码通常意味着更好的可维护性以及可靠性。

简单的设计哲学是 Go 生产力的源泉。

### 显式

首先，我们先来看一段 C 程序，看下 “隐式” 代码的行为特性。

在 C 语言中，下面这段代码可以正常编译并输出正确结果：

```c
#include <stdio.h>

int main() {
    short int a = 5;

    int b = 8;
    long c = 0;
    
    c = a + b;
    printf("%ld\n", c);
}
```

在上面这段代码中，变量 a、b 和 c 的类型均不相同，C 语言编译器在编译 c = a + b 这一行时，会自动将短整型变量 a 和整型变量 b，先转换成 long 类型然后相加，并将所有结果存储在 long 类型变量 c 中。

```go
package main

import "fmt"

func main() {
    var a int16 = 5
    var b int = 8
    var c int64

    c = a + b
    fmt.Printf("%d\n", c)
}
```

我们将上面的 C 程序转换为等价的 Go 代码，当编译程序时，会得到这样的编译器错误：“invalid operation：a + b（mismatched types int16 and in）”。我们能看到 Go 与 C 语言的隐式自动类型转换不同，Go 不允许不同类型的整型变量进行混合计算，它同样也不会对其进行隐式的自动转换。

因此，如果要使这段代码通过编译，我们就需要对变量 a 和 b 进行显式转型，就像下面这段代码：

```go
c = int64(a) + int64(b)
fmt.Printf("%d\n", c)
```

这其实就是 Go 语言显式设计哲学的体现。

在 Go 语言中，不同类型变量是不能在一起进行混合计算的，这是因为 Go 希望开发人员明确知道自己在做什么，你需要以显式的方式通过转型统一参与计算各个变量的类型。

初次之外，Go 设计者所崇尚的显式哲学还直接决定了 Go 语言错误处理的形态：Go 语言采用显式的基于值的错误处理方案，函数/方法中的错误都会通过 return 语句显式地返回，并且通常调用者不能忽略对返回的错误进行处理。

### 组合

这个设计哲学和我们的各个程序之间的耦合有关，Go 语言不像 C++、Java 等主流面向对象语言，我们在 Go 中见不到经典的面向对象语法元素、类型体系和继承机制，Go 崇尚的是组合的设计哲学。

在 Go 语言设计层面，Go 设计者为开发者们提供正交的语法元素，以供后续组合使用，包括：

* Go 语言无类型层次体系，各类型之间是相互独立的，没有子类型的概念；
* 每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的；
* 实现某个接口时，无需像 Java 那样采用特定关键字修饰；
* 包之间是相互独立的，没有子包的概念。

> 正交指相互独立，不可替代，并且组合起来可实现其它功能。

无论是包、接口还是具体类型定义，GO 语言其实为我们呈现这样的一幅图景：一座座没有关联的 “孤岛”，但每个岛内又很精彩。Go 采用组合的方式在这些孤岛之间建立关联，形成一个整体。

Go 语言为支撑组合的设计提供了类型嵌入（Type Embedding）。通过类型嵌入，我们可以将已实现的功能嵌入到新类型中，以快速满足新类型的功能需求，这种方式有点类似面向对象语言中的 “继承” 机制，但在原理上完全不同，这是一种 Go 设计者们精心设计的 “语法糖”。

被嵌入的类型和新类型两者之间没有任何关系，甚至相互完全不知道对方的存在，没有面向对象语言中的那种父类、子类的关系，以及向上、向下转型（Type Casting）。通过新类型实例调用方法时，方法的匹配主要取决于方法名字，而不是类型。这种组合方式，可以称之为垂直组合，即通过类型嵌入，快速让一个新类型 “复用” 其他类型已经实现的能力，实现功能的垂直扩展。

下面是 Go 标准库中的一段使用类型嵌入组合方式的代码段：

```go
// $GOROOT/src/sync/pool.go
type poolLocal struct {
    private interface{}   
    shared  []interface{}
    Mutex               
    pad     [128]byte  
}
```

在代码段中，我们在 poolLocal 这个结构体类型中嵌入类型 Mutex，这使得 poolLocal 这个类型具有互斥同步的能力，我们可以通过 poolLocal 类型的变量，直接调用 Mutex 类型的方法 Lock 或 Unlock。

另外，我们在标准库中还会看到类似如下定义接口类型的代码段：

```go
// $GOROOT/src/io/io.go
type ReadWriter interface {
    Reader
    Writer
}
```

这里，标准库通过嵌入接口类型的方式来实现接口行为的聚合，组成大接口，这种方式在标准库中尤为常用，并且已经成为 Go 语言的一种惯用法。

垂直组合本质上是一种 “能力继承”，采用嵌入方式定义的新类型继承嵌入类型的能力。Go 还有一种常见的组合方式，叫水平组合。和垂直组合的能力继承不同，水平组合是一种能力委托（Delegate），我们通常使用接口类型来实现水平组合。

Go 语言中的接口是一个创建设计，它知识方法集合，并且它与实现者之间的关系无需通过显式关键字修饰，它让程序内部各部分之间的耦合降至最低，同时它也是连接程序各个部分之间的 “纽带”。

水平组合的模式有很多，比如一种常见方法就是，通过接受接口类型参数的普通函数进行组合，如以下代码所示：

```go
// $GOROOT/src/io/ioutil/ioutil.go
func ReadAll(r io.Reader)([]byte, error)

// $GOROOT/src/io/io.go
func Copy(dst Writer, src Reader)(written int64, err error)
```

函数 ReadAll 通过 io.Reader 这个接口，将 io.Reader 的实现与 ReadAll 所在的包低耦合地水平组合在一起，从而达到从任意实现 io.Reader 的数据源读取所有数据的目的。类似的水平组合 “模式” 还有点缀器、中间件等。

此外，我们还可以将 Go 语言内置的并发能力进行灵活组合以实现，比如，通过 goroutine + channel 的组合，可以实现类似 Unix Pipe 的能力。

总之，组合原则的应用实质上是塑造 Go 程序的骨架结构。类型嵌入为类型提供了垂直扩展能力，而接口是水平组合的关键，它好比程序肌体上的 “关节”，给予连接 “关节” 的两个部分各自 “自由活动” 的能力，而整体上又实现某种功能。并且，组合也让遵循 “简单” 原则的 Go 语言，在表现力上丝毫不逊色于其他复杂的主流编程语言。

### 并发

“并发” 这个设计哲学的出现也有有它的背景，CPU 都是靠提高主频来改进性能的，但是这个做法已经遇到瓶颈。主频提高导致 CPU 的功耗和发热量剧增，反过来制约 CPU 性能的进一步提高。2007 年开始，处理器厂商的竞争焦点从主频转向了多核。

在这种大背景下，Go 的设计者在决定创建一门新语言的时候，果断将面向多核、原生支持并发作为新语言的设计原则之一。并且，Go 放弃了传统的基于操作系统线程的并发模型，采用用户层轻量级线程，Go 将之称之为 goroutine。

goroutine 占用的资源非常小，Go 运行时默认为每个 goroutine 分配的占空间仅 2 KB。goroutine 调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，一个 Go 程序中可以创建成千上万个并发的 goroutine。而且，所有的 Go 代码都在 goroutine 中执行，哪怕是 go 运行时的代码也不例外。

在提供了开销较低的 goroutine 的同时，Go 还在语言层面上内置了辅助并发设计的原语：channel 和 select。开发者可以通过语言内置的 channel 传递消息或实现同步，并通过 select 实现多路 channel 的并发控制。相较于传统复杂的线程并发模型，Go 与并发的原生支持将大大降低开发人员在开发并发程序时的心智负担。

此外，并发的设计哲学不仅仅让 Go 在语法层面提供了并发原语支持，对 Go 应用程序设计的影响更为重要。并发是一种程序结构设计的方法，使得并行成为可能。

采用并发方案设计的程序在单核处理器也是可以正常运行的，也许在单核上的处理性能可能不如非并发方案。但随着处理器核数的增多，并发方案可以自然地提高处理性能。

而且，并发与组合的哲学是一脉相承的，并发是一个更大的组合概念，它在程序设计的全局层面对程序进行拆解组合，再映射到程序执行层面上：goroutines 各自执行特定的工作，通过 channel + select 将 goroutines 组合连接起来。并发的存在鼓励程序员在程序设计时进行独立计算的分解，而对并发的原生支持让 Go 语言更适合现代计算环境。

### 面向工程

Go 语言设计的初衷，就是面向解决真实世界中 Google 内部大规模软件开发中存在的各种问题，为这些问题提供答案，例如：程序构建慢、依赖管理失控、代码难于理解、跨语言构建难等。

Go语言最初设计阶段就将解决工程问题作为 Go 的设计原则之一，去考虑 Go 语法、工具链与标准库的设计，这也是 Go 与其他偏学院派、偏研究型的编程语言在设计思路上的一个重要差异。

语法是编程语言的用户接口，它直接影响开发人员对这门语言的使用体验。在面向工程设计哲学的驱使下，Go 在语法设计细节上做了精心打磨。

* 重新设计编译单元和目标文件格式，实现 Go 源码快速构建，使大工程的构建时间缩短到类似动态语言的交互式解释的编译速度；
* 如果源文件导入它不使用的包，程序将无法编译。这可以充分保证任何 Go 程序的依赖树是精确的，也可以保证构建程序时不会编译额外的代码，从而最大限度地缩短编译时间；
* 去除包的循环依赖，循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建；
* 包路径是唯一的，包名不必唯一。导入路径必须唯一标识要导入的包，名称只是包的使用者如何引用其内容的约定。“包名称不必是唯一的” 这个约定，可以大大降低开发人员给包起唯一名字的心智负担；
* 不支持默认函数参数。因为在规模工程中，很多开发者利用默认函数参数机制，向函数添加过多的参数以弥补函数 API 的设计缺陷，这会导致函数拥有太多的参数，降低清晰度和可读性；
* 增加类型别名（type alias），支持大规模代码库重构。

在标准库方面，Go 语言标准库功能丰富，多数功能不需要依赖外部的第三方包或库。Go 在标准库中提供了各种高质量且性能优良的功能包，其中 net/http、crypto、encoding 等包充分迎合了云原生时代的关于
